"""Extended Reality Open Recording (XROR)."""

import numpy as np
import fpzip
import bson
import time
import datetime
from .Bsor import make_bsor
from copy import deepcopy

class XROR:
    """
    Represents an Extended Reality Open Recording (XROR) object.

    Contains a recording consisting of motion data and events generated by a virtual or augmented reality application.
    """

    def __init__(self, id = None, name = None, timestamp = None):
        """
        Initialize an empty Extended Reality Open Recording (XROR) object.

        Parameters:
            id:A unique identifier for this recording.
            name(str):The name of this recording.
            timestamp(int):Unix timestamp for the start of this recording.
        """
        self.data = {
            "$schema": "https://metaguard.github.io/xror/schema/v1.0.0/schema.json"
        }
        if (id): self.data['$id'] = id
        self.data['info'] = {}
        if (name): self.info['name'] = str(name)
        if (timestamp): self.data['info']['timestamp'] = int(timestamp)
        self.data['info']['hardware'] = {}
        self.data['info']['hardware']['devices'] = []
        self.data['frames'] = []
        self.data['events'] = []

    def __repr__(self):
        """Return a string representation of the XROR data."""
        return repr(self.data)

    def addDevice(self, name = None, type = None, joint = None, axes = ['x', 'y', 'z', 'i', 'j', 'k', '1'], offsets = None):
        """
        Add a new hardware devices associated with this XROR recording.

        Parameters:
            name(str):The name of the hardware device.
            type(str):The type of the hardware device.
            joint(str):The location of the hardware device on the user's body.
            axes(list):The names of the tracked dimensions associated with this device.
            offsets(list):The offsets of the tracked dimensions associated with this device relative to the origin.
        """
        device = {}
        if (name): device['name'] = name
        if (type): device['type'] = type
        if (joint): device['joint'] = joint
        device['axes'] = axes
        if (offsets): device['offsets'] = offsets
        self.data['info']['hardware']['devices'].append(device)

    def setApp(self, id = None, name = None, version = None):
        """
        Set metadata about the application associated with this XROR recording.

        Parameters:
            id:A unique identifier for the application associated with this recording.
            name(str):The name of the application associated with this recording.
            version(str):The version number of the application associated with this recording.
        """
        if ('software' not in self.data['info']): self.data['info']['software'] = {}
        app = {}
        if (id): app['id'] = id
        if (name): app['name'] = name
        if (version): app['version'] = version
        self.data['info']['software']['app'] = app

    def addExtension(self, id = None, name = None, version = None):
        """
        Add a new extension to the application associated with this XROR recording.

        Parameters:
            id:A unique identifier for the extension.
            name(str):The name of the extension.
            version(str):The version number of the extension.
        """
        if ('software' not in self.data['info']): self.data['info']['software'] = {}
        if ('app' not in self.data['info']['software']): self.data['info']['software']['app'] = {}
        if ('extensions' not in self.data['info']['software']['app']): self.data['info']['software']['app']['extensions'] = []

        mod = {}
        if (id): mod['id'] = id
        if (name): mod['name'] = name
        if (version): mod['version'] = version
        self.data['info']['software']['app']['extensions'].append(mod)

    def setEnvironment(self, id = None, name = None):
        """
        Set metadata about the virtual environment associated with this XROR recording.

        Parameters:
            id:A unique identifier for the environment associated with this recording.
            name(str):The name of the virtual environment associated with this recording.
        """
        if ('software' not in self.data['info']): self.data['info']['software'] = {}
        env = {}
        if (id): env['id'] = id
        if (name): env['name'] = name
        self.data['info']['software']['environment'] = env

    def setActivity(self, id = None, name = None):
        """
        Set metadata about the activity associated with this XROR recording.

        Parameters:
            id:A unique identifier for the activity associated with this recording.
            name(str):The name of the activity associated with this recording.
        """
        if ('software' not in self.data['info']): self.data['info']['software'] = {}
        act = {}
        if (id): act['id'] = id
        if (name): act['name'] = name
        self.data['info']['software']['activity'] = act

    def setUser(self, id = None, name = None):
        """
        Set metadata about the user associated with this XROR recording.

        Parameters:
            id:A unique identifier for the user associated with this recording.
            name(str):The name of the user associated with this recording.
        """
        usr = {}
        if (id): usr['id'] = id
        if (name): usr['name'] = name
        self.data['info']['user'] = usr

    def addFrame(self, time, data):
        """
        Add a single frame of motion data to this XROR recording.

        Parameters:
            time(float):Time of the frame in seconds elapsed since the start of the recording.
            data(list):Telemetry data associated with the frame, with one number for each tracked axis specified in devices.
        """
        self.data['frames'].append([time] + data)

    def addEventType(self, id = None, name = None, attr = None, floatData = None, otherData = None):
        """
        Add a new type of event to this XROR recording.

        Parameters:
            id:A unique identifier for the type of event.
            name(str):The name of the type of event.
            attr(list):The names of the attributes associated with this type of event. Lists all floating-point attributes first, followed by all other attributes.
            floatData(list):The occurrences of the event type contained in this recording; 2D array of floats, with one entry per occurrence. Each entry starts with the time of the event in seconds elapsed since the start of the recording, and then includes the floating point attribute values associated with the occurrence.
            otherData(list):The occurrences of the event type contained in this recording; consists of a 2D array of values, with one entry per occurrence. Each entry includes the non-float attribute values associated with the occurrence.
        """
        if ('events' not in self.data): self.data['events'] = []
        ev = {}
        if (id): ev['id'] = id
        if (name): ev['name'] = name
        if (attr): ev['attr'] = attr
        if (floatData): ev['floatData'] = floatData
        if (otherData): ev['otherData'] = otherData
        self.data['events'].append(ev)

    def addEvent(self, type, time, floatData = [], otherData = None):
        """
        Add a single new event occurrence to this XROR recording.

        Parameters:
            type(str):The id of the type of event to add.
            time(float):The time of the event occurrence in seconds elapsed since the start of the recording.
            floatData(list):The floating point attribute values associated with the occurrence.
            otherData(list):The non-float attribute values associated with the occurrence.
        """
        idx = None;
        for i in range(len(self.data['events'])):
            if (self.data['events'][i]['id'] == type): idx = i
        if ('floatData' not in self.data['events'][idx]): self.data['events'][idx]['floatData'] = []
        self.data['events'][idx]['floatData'].append([time] + floatData)
        if (otherData):
            if ('otherData' not in self.data['events'][idx]): self.data['events'][idx]['otherData'] = []
            self.data['events'][idx]['otherData'].append(otherData)

    def getEvents(self, type):
        """
        Get all occurrences of event of specified type.

        Parameters:
            type(str):The id of the type of event to fetch occurrences of.
        """
        idx = None;
        for i in range(len(self.data['events'])):
            if (self.data['events'][i]['id'] == type): idx = i
        if (idx == None): return None
        events = []
        if ('floatData' not in self.data['events'][idx]): return []
        keys = ['time'] + self.data['events'][idx]['attr']
        for i in range(len(self.data['events'][idx]['floatData'])):
            if self.data['events'][idx]['floatData'][i][0] == -1: continue
            event = {}
            for j in range(len(self.data['events'][idx]['floatData'][i])):
                event[keys[j]] = self.data['events'][idx]['floatData'][i][j]
            if 'otherData' in self.data['events'][idx]:
                for k in range(len(self.data['events'][idx]['otherData'][i])):
                    event[keys[j+k+1]] = self.data['events'][idx]['otherData'][i][k]
            events.append(event)
        return events

    def pack(self):
        """
        Generate raw data for an XROR file from this object.

        Compresses telemetry and event data using fpzip, then packs object using BSON.
        """
        def compress(array):
            try:
                floats = np.array(array, dtype=np.float32)
                bytes = fpzip.compress(floats)
                return bson.binary.Binary(bytes)
            except:
                floats = np.array(array, dtype=np.float32)
                padding = np.array(np.full(np.shape(array), -1))
                padded = np.vstack([floats, padding, padding])
                bytes = fpzip.compress(padded)
                return bson.binary.Binary(bytes)

        data = deepcopy(self.data)

        if ('timestamp' in data['info']): data['info']['timestamp'] = datetime.datetime.fromtimestamp(data['info']['timestamp'], datetime.timezone.utc)

        data['frames'] = compress(data['frames'])

        for i in range(len(data['events'])):
            if ('floatData' in data['events'][i]):
                data['events'][i]['floatData'] = compress(data['events'][i]['floatData'])

        return bson.encode(data)

    def toBSOR(self):
        """Generate raw data for a BSOR file from this object."""
        bytes = bytearray()
        def addInt(i):
            bytes.extend(int(i).to_bytes(4, 'little'));

        def addLong(i):
            bytes.extend(int(i).to_bytes(8, 'little'));

        def addFloat(float):
            bytes.extend(np.array([float], dtype=np.float32).tobytes());

        def addByte(byte):
            bytes.extend(byte.to_bytes(1, 'little'))

        def addString(str):
            enc = str.encode('utf-8')
            addInt(len(str))
            bytes.extend(enc)

        # Info Structure
        addInt(0x442d3d69)
        addByte(1)
        addByte(0)
        addString(self.data['info']['software']['app']['extensions'][0]['version'])
        addString(self.data['info']['software']['app']['version'])
        addString(str(self.data['info']['timestamp']))
        addString(self.data['info']['user']['id'])
        addString(self.data['info']['user']['name'] if 'name' in self.data['info']['user'] else '')
        addString(self.data['info']['software']['runtime'])
        addString(self.data['info']['software']['api'])
        addString(self.data['info']['hardware']['devices'][0]['name'] if 'name' in self.data['info']['hardware']['devices'][0] else '')
        addString(self.data['info']['hardware']['devices'][2]['name'] if 'name' in self.data['info']['hardware']['devices'][2] else '')
        for attr in ['songHash', 'name', 'mapper', 'difficulty']:
            addString(self.data['info']['software']['activity'][attr])
        addInt(self.data['info']['software']['activity']['score'])
        addString(self.data['info']['software']['activity']['mode'])
        addString(self.data['info']['software']['environment']['name'])
        if ('modifiers' in self.data['info']['software']['activity']): addString(self.data['info']['software']['activity']['modifiers'])
        else: addString("")
        if ('jumpDistance' in self.data['info']['software']['activity']): addFloat(self.data['info']['software']['activity']['jumpDistance'])
        else: addFloat(0.0)
        if ('leftHanded' in self.data['info']['software']['activity']): addByte(self.data['info']['software']['activity']['leftHanded'])
        else: addByte(False)

        for attr in ['height', 'startTime', 'failTime', 'speed']:
            if (attr in self.data['info']['software']['activity']): addFloat(self.data['info']['software']['activity'][attr])
            else: addFloat(0)

        # Frames Array
        addByte(1)
        addInt(len(self.data['frames']))
        fps = self.getEvents('f')
        for i in range(len(self.data['frames'])):
            frame = self.data['frames'][i]
            addFloat(frame[0])
            if fps: addInt(int(fps[i]['fps']))
            else: addInt(0)
            for j in range(1, 22):
                addFloat(frame[j])

        # Notes Array
        addByte(2)
        notes = []
        gc = self.getEvents('gc')
        for c in gc:
            c['eventType'] = 0
            c['speedOK'] = True
            c['directionOK'] = True
            c['saberTypeOK'] = True
            c['wasCutTooSoon'] = False
        bc = self.getEvents('bc')
        for c in bc:
            c['eventType'] = 1
        m = self.getEvents('m')
        for c in m:
            c['eventType'] = 2
        b = self.getEvents('b')
        for c in b:
            c['eventType'] = 3
        notes = sum([gc, bc, m, b], [])
        if ('order' in notes[0]): notes = sorted(notes, key=lambda d: d['order'])
        else: notes = sorted(notes, key=lambda d: d['time'])
        g = self.getEvents('g')
        gi = 0
        addInt(len(notes))
        for note in notes:
            addInt(note['noteID'])
            addFloat(note['time'])
            addFloat(note['spawnTime'])
            addInt(note['eventType'])
            if (note['eventType'] == 0 or (note['eventType'] == 1 and self.data['info']['software']['runtime'] != "oculus")):
                for attr in ['speedOK', 'directionOK', 'saberTypeOK', 'wasCutTooSoon']: addByte(note[attr])
                for attr in ['saberSpeed', 'saberDirX', 'saberDirY', 'saberDirZ']: addFloat(note[attr])
                addInt(note['saberType'])
                for attr in ['timeDeviation', 'cutDirDeviation', 'cutPointX', 'cutPointY', 'cutPointZ', 'cutNormalX', 'cutNormalY', 'cutNormalZ', 'cutDistanceToCenter', 'cutAngle', 'beforeCutRating', 'afterCutRating']: addFloat(note[attr])
            elif (note['eventType'] == 1 and self.data['info']['software']['runtime'] == "oculus"):
                if (g):
                    bytes.extend(g[gi]['data'])
                    gi += 1
                else:
                    for attr in ['speedOK', 'directionOK', 'saberTypeOK', 'wasCutTooSoon']: addByte(0)
                    for attr in ['saberSpeed', 'saberDirX', 'saberDirY', 'saberDirZ']: addFloat(0.0)
                    addInt(0.0)
                    for attr in ['timeDeviation', 'cutDirDeviation', 'cutPointX', 'cutPointY', 'cutPointZ', 'cutNormalX', 'cutNormalY', 'cutNormalZ', 'cutDistanceToCenter', 'cutAngle', 'beforeCutRating', 'afterCutRating']: addFloat(0.0)

        # Walls Array
        addByte(3)
        walls = self.getEvents('wh')
        addInt(len(walls))
        for wall in walls:
            addInt(wall['wallID'])
            addFloat(wall['energy'])
            addFloat(wall['time'])
            addFloat(wall['spawnTime'])

        # Height Array
        addByte(4)
        heights = self.getEvents('h')
        addInt(len(heights))
        for height in heights:
            addFloat(height['height'])
            addFloat(height['time'])

        # Pause Array
        addByte(5)
        pauses = self.getEvents('p')
        addInt(len(pauses))
        for pause in pauses:
            addLong(pause['duration'])
            addFloat(pause['time'])

        return bytes

    @classmethod
    def unpack(XROR, file):
        """
        Generate XROR object from XROR file data.

        Unpacks XROR file data using BSON, then decompresses telemetry and event data using fpzip.
        """
        xror = XROR()
        data = bson.decode(file)

        if ('timestamp' in data['info']):data['info']['timestamp'] = int(data['info']['timestamp'].replace(tzinfo=datetime.timezone.utc).timestamp())

        floats = fpzip.decompress(data['frames'])
        data['frames'] = floats[0][0].tolist()

        for i in range(len(data['events'])):
            if ('floatData' in data['events'][i]):
                floats = fpzip.decompress(data['events'][i]['floatData'])
                data['events'][i]['floatData'] = floats[0][0].tolist()

        xror.data = data
        return xror

    @classmethod
    def fromTilt(XROR, data):
        """
        Generate XROR object from .tilt file data.

        Parameters:
            data:The tilt file pointer to generate an XROR object from.
        """
        tilt = Tilt(data)
        sketch = tilt.sketch
        meta = tilt.metadata
        brushes = meta['BrushIndex']

        xror = XROR()
        xror.setApp(id = '327140', name = 'Tilt Brush')
        if ('EnvironmentPreset' in meta): xror.setEnvironment(id = meta['EnvironmentPreset'])
        for attr in ['ThumbnailCameraTransformInRoomSpace', 'SceneTransformInRoomSpace', 'Mirror', 'Lights']:
            if attr in meta:
                xror.data['info']['software']['environment'][attr] = meta[attr]

        xror.addDevice(name = 'BRUSH', type = 'OTHER', axes = ['x', 'y', 'z', 'i', 'j', 'k', '1', 'p'])
        xror.addEventType(id = 'stroke', name = 'Stroke', attr = ['color_r', 'color_g', 'color_b', 'color_a', 'size', 'scale', 'brush']);

        for stroke in sketch.strokes:
            brush = brushes[stroke.brush_idx]
            time = stroke.get_cp_extension(stroke.controlpoints[0], 'timestamp')
            color = stroke.brush_color
            xror.addEvent('stroke', time, [color[0], color[1], color[2], color[3], stroke.brush_size, stroke.scale], [brush])
            for point in stroke.controlpoints:
                time = stroke.get_cp_extension(point, 'timestamp')
                x = point.position[0]
                y = point.position[1]
                z = point.position[2]
                i = point.orientation[0]
                j = point.orientation[1]
                k = point.orientation[2]
                l = point.orientation[3]
                p = stroke.get_cp_extension(point, 'pressure')
                xror.addFrame(time, [x, y, z, i, j, k, l, p])

        return xror

    @classmethod
    def fromBSOR(XROR, data, addFPS = False, addOrder = False, addGarbage = False):
        """
        Generate XROR object from BSOR file data.

        Parameters:
            data:The bsor file pointer to generate an XROR object from.
            addFPS(bool):Whether to add FPS data to the XROR object. Often not necessary.
            addOrder(bool):Whether to add event order data to the XROR object. Only needed in edge cases.
            addGarbage(bool):Whether to include garbage cut data from bad cuts on Oculus devices.
        """
        bsor = make_bsor(data)
        xror = XROR(timestamp = bsor.info.timestamp)

        xror.addDevice(name = bsor.info.hmd, type = 'HMD', joint = 'HEAD')
        xror.addDevice(name = bsor.info.controller.replace("right", "left").replace("Right", "Left").replace("RIGHT", "LEFT"), type = 'CONTROLLER', joint = 'HAND_LEFT')
        xror.addDevice(name = bsor.info.controller, type = 'CONTROLLER', joint = 'HAND_RIGHT')

        xror.setApp(id = '620980', name = 'Beat Saber', version = bsor.info.gameVersion)
        xror.addExtension(name = 'BeatLeader', version = bsor.info.version)
        xror.setEnvironment(name = bsor.info.environment)
        xror.setActivity(name = bsor.info.songName)
        xror.setUser(id = bsor.info.playerId, name = bsor.info.playerName)
        for attr in ['songHash', 'mapper', 'difficulty', 'score', 'mode', 'modifiers', 'jumpDistance', 'leftHanded', 'height', 'startTime', 'failTime', 'speed']:
            if (getattr(bsor.info, attr)): xror.data['info']['software']['activity'][attr] = getattr(bsor.info, attr)
        xror.data['info']['software']['runtime'] = bsor.info.platform
        xror.data['info']['software']['api'] = bsor.info.trackingSystem

        for frame in bsor.frames:
            data = []
            for obj in ['head', 'left_hand', 'right_hand']:
                for axis in ['x', 'y', 'z', 'x_rot', 'y_rot', 'z_rot', 'w_rot']:
                    data.append(getattr(getattr(frame, obj), axis))
            xror.addFrame(frame.time, data)

        if addOrder:
            xror.addEventType(id = 'gc', name = 'Good Cut', attr = ['spawnTime', 'saberSpeed', 'saberDirX', 'saberDirY', 'saberDirZ', 'timeDeviation', 'cutDirDeviation', 'cutPointX', 'cutPointY', 'cutPointZ', 'cutNormalX', 'cutNormalY', 'cutNormalZ', 'cutDistanceToCenter', 'cutAngle', 'beforeCutRating', 'afterCutRating', 'noteID', 'saberType', 'order']);
            if (bsor.info.platform == "oculus"):
                xror.addEventType(id = 'bc', name = 'Bad Cut', attr = ['spawnTime', 'noteID', 'order']);
                if (addGarbage): xror.addEventType(id = 'g', name = 'Garbage', attr = ['data']);
            else:
                xror.addEventType(id = 'bc', name = 'Bad Cut', attr = ['spawnTime', 'saberSpeed', 'saberDirX', 'saberDirY', 'saberDirZ', 'timeDeviation', 'cutDirDeviation', 'cutPointX', 'cutPointY', 'cutPointZ', 'cutNormalX', 'cutNormalY', 'cutNormalZ', 'cutDistanceToCenter', 'cutAngle', 'beforeCutRating', 'afterCutRating', 'noteID', 'speedOK', 'directionOK', 'saberTypeOK', 'wasCutTooSoon', 'saberType', 'order']);
            xror.addEventType(id = 'm', name = 'Miss', attr = ['spawnTime', 'noteID', 'order']);
            xror.addEventType(id = 'b', name = 'Bomb Cut', attr = ['spawnTime', 'noteID', 'order']);
        else:
            xror.addEventType(id = 'gc', name = 'Good Cut', attr = ['spawnTime', 'saberSpeed', 'saberDirX', 'saberDirY', 'saberDirZ', 'timeDeviation', 'cutDirDeviation', 'cutPointX', 'cutPointY', 'cutPointZ', 'cutNormalX', 'cutNormalY', 'cutNormalZ', 'cutDistanceToCenter', 'cutAngle', 'beforeCutRating', 'afterCutRating', 'noteID', 'saberType']);
            if (bsor.info.platform == "oculus"):
                xror.addEventType(id = 'bc', name = 'Bad Cut', attr = ['spawnTime', 'noteID']);
                if (addGarbage): xror.addEventType(id = 'g', name = 'Garbage', attr = ['data']);
            else:
                xror.addEventType(id = 'bc', name = 'Bad Cut', attr = ['spawnTime', 'saberSpeed', 'saberDirX', 'saberDirY', 'saberDirZ', 'timeDeviation', 'cutDirDeviation', 'cutPointX', 'cutPointY', 'cutPointZ', 'cutNormalX', 'cutNormalY', 'cutNormalZ', 'cutDistanceToCenter', 'cutAngle', 'beforeCutRating', 'afterCutRating', 'noteID', 'speedOK', 'directionOK', 'saberTypeOK', 'wasCutTooSoon', 'saberType']);
            xror.addEventType(id = 'm', name = 'Miss', attr = ['spawnTime', 'noteID']);
            xror.addEventType(id = 'b', name = 'Bomb Cut', attr = ['spawnTime', 'noteID']);


        for [idx, note] in enumerate(bsor.notes):
            if note.event_type == 0:
                xror.addEvent('gc', note.event_time, [note.spawn_time, note.cut.saberSpeed, note.cut.saberDirection[0], note.cut.saberDirection[1], note.cut.saberDirection[2], note.cut.timeDeviation, note.cut.cutDeviation, note.cut.cutPoint[0], note.cut.cutPoint[1], note.cut.cutPoint[2], note.cut.cutNormal[0], note.cut.cutNormal[1], note.cut.cutNormal[2], note.cut.cutDistanceToCenter, note.cut.cutAngle], [note.cut.beforeCutRating, note.cut.afterCutRating, note.note_id, note.cut.saberType, idx] if addOrder else [note.cut.beforeCutRating, note.cut.afterCutRating, note.note_id, note.cut.saberType])
            if note.event_type == 1:
                if (bsor.info.platform == "oculus"):
                    xror.addEvent('bc', note.event_time, [note.spawn_time], [note.note_id, idx] if addOrder else [note.note_id])
                    if (addGarbage): xror.addEvent('g', note.event_time, [], [note.garbage])
                else:
                    xror.addEvent('bc', note.event_time, [note.spawn_time, note.cut.saberSpeed, note.cut.saberDirection[0], note.cut.saberDirection[1], note.cut.saberDirection[2], note.cut.timeDeviation, note.cut.cutDeviation, note.cut.cutPoint[0], note.cut.cutPoint[1], note.cut.cutPoint[2], note.cut.cutNormal[0], note.cut.cutNormal[1], note.cut.cutNormal[2], note.cut.cutDistanceToCenter, note.cut.cutAngle], [note.cut.beforeCutRating, note.cut.afterCutRating, note.note_id, note.cut.speedOK, note.cut.directionOk, note.cut.saberTypeOk, note.cut.wasCutTooSoon, note.cut.saberType, idx] if addOrder else [note.cut.beforeCutRating, note.cut.afterCutRating, note.note_id, note.cut.speedOK, note.cut.directionOk, note.cut.saberTypeOk, note.cut.wasCutTooSoon, note.cut.saberType])
            if note.event_type == 2:
                xror.addEvent('m', note.event_time, [note.spawn_time], [note.note_id, idx] if addOrder else [note.note_id])
            if note.event_type == 3:
                xror.addEvent('b', note.event_time, [note.spawn_time], [note.note_id, idx] if addOrder else [note.note_id])

        xror.addEventType(id = 'wh', name = 'Wall Hit', attr = ['energy', 'spawnTime', 'wallID'])
        for wall in bsor.walls:
            xror.addEvent('wh', wall.time, [wall.energy, wall.spawnTime, wall.id])

        xror.addEventType(id = 'h', name = 'Height Change', attr = ['height'])
        for height in bsor.heights:
            xror.addEvent('h', height.time, [height.height])

        xror.addEventType(id = 'p', name = 'Pause', attr = ['duration'])
        for pause in bsor.pauses:
            xror.addEvent('p', pause.time, otherData=[pause.duration])

        if (addFPS):
            xror.addEventType(id = 'f', name = 'FPS', attr = ['fps'])
            for frame in bsor.frames:
                xror.addEvent('f', frame.time, [frame.fps])

        # todo: bomb misses
        # todo: wall misses
        # todo: more user data

        return xror
